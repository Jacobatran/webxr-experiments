<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>WebXR + ThreeJS Application</title>
    <script>
        (function(f, a, t, h, o, m){
            a[h]=a[h]||function(){
                (a[h].q=a[h].q||[]).push(arguments)
            };
            o=f.createElement('script'),
                m=f.getElementsByTagName('script')[0];
            o.async=1; o.src=t; o.id='fathom-script';
            m.parentNode.insertBefore(o,m)
        })(document, window, '//stats.josh.earth/tracker.js', 'fathom');
        fathom('set', 'siteId', 'GISNV');
        fathom('trackPageview');
    </script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style type="text/css">
        body {
            max-width: 40em;
            margin: auto;
        }
        #container {
            border: 3px solid red;
            width: 500px;
            height: 300px;
        }
        #fullscreen, #entervr {
            display: none;
        }
    </style>
</head>
<body>

<h1>WebXR ThreeJS + VR Boilerplate App</h1>
<p><i>created by <a href="https://twitter.com/joshmarinacci">Josh Marinacci</a>, Mozilla Mixed Reality</i></p>
<p>
    This WebXR boilerplate is easy to use. Just view the source or get
    your own copy at <a href="https://github.com/joshmarinacci/webxr-boilerplate/">github</a>
    It creates a simple ThreeJS scene with a stats viewer, a pointer abstraction, and hooks to detect VR support.
    Best of all it uses only ES6 Modules.
</p>

<p>
    Press <b>play full screen</b> in desktop mode. Press <b>play in vr</b> to play in VR mode (if available).
    You can click on the cube to change its color and play a sound effect.
    When you enter VR or full screen the background music will play.
</p>

<div>
    <div id="progress">
        <label>loading</label>
        <progress id="progress-bar" value="0.5"></progress>
    </div>
    <button id="fullscreen">play full screen</button>
    <button id="entervr">play in vr</button>
</div>
<div id="container"></div>

<ul>
    <li>Example music from <a href="http://freemusicarchive.org/music/BoxCat_Games/Nameless_the_Hackers_RPG_Soundtrack/BoxCat_Games_-_Nameless-_the_Hackers_RPG_Soundtrack_-_10_Epic_Song">BoxCat Games</a></li>
    <li>Example sound effects from <a href="https://freesound.org/people/suonidigenova/sounds/55055/">Souni Di Genova</a></li>
    <li>Cat image from <a href="http://creative-commons-cats.tumblr.com/page/3">Creative Commons Cats</a></li>
</ul>

<script src="node_modules/atlaspack/index.js"></script>
<script type="module">
    // converter function from chunks to meshs
    import GreedyMesh from "./greedy.js"
    // managers chunks
    import {Chunker} from "./chunker.js"
    //converts chunks to three mesh
    import {VoxelMesh} from "./mesh.js"
    import {VoxelTexture} from "./voxelTexture.js"

    import WebXRBoilerPlate from "./WebXRBoilerPlate.js"
    import {Mesh, BoxBufferGeometry, MeshLambertMaterial,
        Color, DirectionalLight, AmbientLight, Vector3,
        TextureLoader, Group, DoubleSide, FrontSide
    } from "./node_modules/three/build/three.module.js"
    import * as THREE from "./node_modules/three/build/three.module.js"
    import ThreeDOFController from "./threedof"
    import {Pointer} from "./Pointer.js"
    import {traceRay} from "./raycast.js"
    import {POINTER_CLICK} from './Pointer'


    //JQuery-like selector
    const $ = (sel) => document.querySelector(sel)
    const on = (elem, type, cb) => elem.addEventListener(type,cb)
    const toRad = (deg) => Math.PI / 180 * deg

    const app = new WebXRBoilerPlate({
        container: $("#container")
    })
    app.init().then((app) => {
        app.scene.background = new Color( 0xcccccc );

        const pointer = new Pointer(app,{
            //Pointer searches everything in the scene by default
            //override this to match just certain things
            intersectionFilter: ((o) => o.userData.clickable),

            //make the camera pan when moving the mouse. good for simulating head turning on desktop
            cameraFollowMouse:false,

            // set to true to move the controller node forward and tilt with the mouse.
            // good for testing VR controls on desktop
            mouseSimulatesController:true,

            //turn this off if you provide your own pointer model
            enableLaser: true,
        })


        //load a cat texture
        const texture_loader = new TextureLoader()
        //cat from http://creative-commons-cats.tumblr.com/page/3
        const texture = texture_loader.load('./cat.jpg')


        const materials = new VoxelTexture({
            THREE:THREE,
            // game: this,
            texturePath: './textures/',
            materialType: MeshLambertMaterial,
            materialParams: { side: DoubleSide},
            // materialFlatColor: opts.materialFlatColor === true
        })
        const materialNames = ['uvgrid', 'brick', 'dirt']
        materials.load(materialNames)


        const valley = (i,j,k) =>  j <= (i*i + k*k) * 31 / (32*32*2) + 1 ? 1 + (1<<15) : 0;
        const flat = (i,j,k) => (j === 0)?1:0

        function generateChunkFromFunction(l, h, f) {
            let d = [ h[0]-l[0], h[1]-l[1], h[2]-l[2] ]
            let v = new Int32Array(d[0]*d[1]*d[2])
            let n = 0;
            for(let k=l[2]; k<h[2]; ++k)
                for(let j=l[1]; j<h[1]; ++j)
                    for(let i=l[0]; i<h[0]; ++i, ++n) {
                        v[n] = f(i,j,k);
                    }
            return {
                low:l,
                high:h,
                voxels:v,
                dims:d,
            };
        }


        const chunker = new Chunker({
            cubeSize:1,
            chunkSize:32,
            generateVoxelChunk:function(low, high) {
                return generateChunkFromFunction(low, high,flat)
            }
        });


        const scale = new Vector3(1.0,1.0,1.0)
        const mesher = new GreedyMesh()


        const stageRot = new THREE.Group()
        app.scene.add(stageRot)
        const stagePos = new THREE.Group()
        stageRot.add(stagePos)

        const group = new Group()
        // app.scene.add(group)
        stagePos.add(group)
        //generate four chunks
        for(let i=0; i<1; i++) {
            for(let j=-1; j<0; j++) {
                const chunk = chunker.generateChunk(i, 0, j)
                const mesh = new VoxelMesh(chunk, mesher, scale)
                const surfaceMesh = mesh.createSurfaceMesh()//materials.material)
                const chunkIndex = chunk.position.join('|')
                chunker.meshes[chunkIndex] = mesh
                surfaceMesh.position.set(i*32,0,j*32)
                // materials.paint(mesh)
                group.add(surfaceMesh)

                console.log("made a chunk")
            }
        }

        group.position.z = 0
        group.position.y = 0
        // group.rotation.x = toRad(90)

        //a standard directional light from above
        const light = new DirectionalLight( 0xffffff, 1.0 );
        light.position.set( 0, 10, 5 ).normalize();
        app.scene.add( light );

        //a standard ambient light
        app.scene.add(new AmbientLight(0xffffff,0.3))


        const controller = new ThreeDOFController(stagePos, stageRot)
        const parseVectorArguments = function(args) {
            if (!args) return false
            if (args[0] instanceof Array) return args[0]
            return [args[0], args[1], args[2]]
        }

        const fakeGame = {
            getBlock:function(pos) {
                pos = parseVectorArguments(arguments)
                // console.log("pos is",pos)
                return chunker.voxelAtPosition(pos)
            },
            setBlock: function(pos, value) {
                // console.log('setting',pos,value)
                const x = Math.floor(pos[0])
                const y = Math.floor(pos[1])
                const z = Math.floor(pos[2]) + 1
                chunker.voxelAtCoordinates(x,y,z, 8)
                console.log("setting at",x,y,z, value)


                const chunkPos = chunker.chunkAtCoordinates(x,y,z)
                // console.log("chunk index is",chunkPos)
                const chunkIndex = chunkPos.join("|")
                const chunk = chunker.chunks[chunkPos.join('|')]
                // console.log("real chunk is",chunk)
                if(!chunk) return

                //rebuild the mesh and surface mesh

                // console.log("embedded chunk is",chunker.chunks[chunkIndex])
                // console.log("current surface mesh is", chunker.meshes[chunkIndex].surfaceMesh)
                const surfaceMesh = chunker.meshes[chunkIndex].surfaceMesh
                // console.log("removing",surfaceMesh,'at',surfaceMesh.position)
                if(surfaceMesh) group.remove(surfaceMesh)
                const mesh = new VoxelMesh(chunk, mesher, scale)
                chunker.meshes[chunkIndex] = mesh
                const newSurfaceMesh = mesh.createSurfaceMesh()//materials.material)
                // materials.paint(mesh)
                group.add(newSurfaceMesh)
                // console.log("index is",chunkIndex, chunkPos)
                newSurfaceMesh.position.set(chunkPos[0]*32,chunkPos[1]*0,chunkPos[2]*32)
                // console.log("new position is", newSurfaceMesh.position)
                // console.log("new data is", mesh.data)
            }
        }

        // things to do on every render tick
        // this is the render loop
        app.onRender((time, app)=> {
            pointer.tick(time)
            materials.tick(time)
            controller.update(time)
            // console.log(pointer.controller1.position)
            const dir = new Vector3(0, 0, -1)
            dir.applyQuaternion(pointer.controller1.quaternion)
            // console.log(dir)

            const epilson = 1e-8
            const pos = pointer.controller1.position
            const hitNormal = [0, 0, 0]
            const distance = 10
            const hitPosition = [0, 0, 0]
            const hitBlock = traceRay(fakeGame,pos,dir,distance,hitPosition,hitNormal,epilson)
            // console.log(hitBlock)
            // console.log('hit the block',hitBlock, hitPosition, hitNormal)
            // group.rotation.y -= 0.005
        })

        pointer.on(POINTER_CLICK,()=>{
            console.log("clicked somewhere")
            const dir = new Vector3(0, 0, -1)
            dir.applyQuaternion(pointer.controller1.quaternion)
            const epilson = 1e-8
            const pos = pointer.controller1.position
            const hitNormal = [0, 0, 0]
            const distance = 10
            const hitPosition = [0, 0, 0]
            const hitBlock = traceRay(fakeGame,pos,dir,distance,hitPosition,hitNormal,epilson)
            // console.log(hitBlock)
            // console.log('hit the block',hitBlock, hitPosition, hitNormal)
            fakeGame.setBlock(hitPosition, 1)
        })



        //update progress indicator while loading
        on(app,'progress',(prog)=> $("#progress").setAttribute('value',100*prog))

        //when all assets are loaded
        on(app,'loaded',()=>{
            // hide the loading progress bar
            $("#progress").style.display = 'none'
            //show the fullscreen button
            $("#fullscreen").style.display = 'block'
            on($("#fullscreen"),'click',()=> {
                app.playFullscreen()
            })
        })
        //when VR support is detected
        on(app,'detected',()=>{
            // show the enter VR button
            $("#entervr").style.display = 'block'
            on($("#entervr"),'click',()=> {
                app.enterVR()
            })
        })



    })


</script>
</body>
</html>
